module Draw(drawWorld, drawLoading) where

import Graphics.Gloss
import Board

import Debug.Trace

-- Find the half size of the board to center the image.
-- @World world to get the size of the board. @Float the size of the board
half :: World -> Float
half w = (fromIntegral (- (( size (board w) - 1) * spacing)) / 2)

-- This function draws the loading page, which has a number of option buttons
-- @IO World to display the board grid. @IO Picture to display the option page on the screen
drawLoading :: IO World -> IO Picture
drawLoading world = do w <- world
                       return $ Pictures ( (Pictures (drawButtonsForLoading w (150, 30) (buttons w))) : [welcomeToGomoku w] )

-- Given a world state, return a Picture which will render the world state.
-- This check whether the game is running or not. If so, this function will print out the game board. Otherwise, it will call the drawLoading function to print out the loading page.
-- @IO World to get information about the buttons on the board. @IO Picture to draw the board on the screen.
drawWorld :: IO World -> IO Picture
drawWorld world = do w <- world
                     if (running w)
                        then return $ Pictures ( Translate (half w) (half w) (Pictures (drawBoard (board w) (0, 0) [] (game_images w))) : (Pictures (drawButtons (buttons w) [] (button_images w)) : (checkEnd w (winscreen_images w))))
                     else (drawLoading world)


-- Draw the board for the Gomoku game. It calls itself recursively to draw all positions.
-- @Board to get the size of the board. @Position to check if the drawBoard function draw all positions on the board, and allows the function to call itself recursively.
-- @[Picture] the list of pictures, which are generated by the drawBoard function. @[Picture] the list of the bmp images. @[Picture] the list that contains all generated pictures in it.
drawBoard :: Board -> Position -> [Picture] -> [Picture] -> [Picture]
drawBoard board (x, y) pics [] = pics
drawBoard board (x, y) pics bmps | x == ((size board) - 1) && y == ((size board) - 1) = drawPiece board (x, y) bmps : pics
                                 | x == ((size board) - 1) = line ((x, y), (x, y + 1)) : drawPiece board (x, y) bmps : drawBoard board (0, y + 1) pics bmps
                                 | y == ((size board) - 1) = line ((x, y), (x + 1, y)) : drawPiece board (x, y) bmps : drawBoard board (x + 1, y) pics bmps
                                 | otherwise = Pictures [line ((x, y), (x + 1, y)), line ((x, y), (x, y + 1))] : drawPiece board (x, y) bmps : drawBoard board (x + 1, y) pics bmps
                                 where line ((x1, y1), (x2, y2)) = Color black $ Line [(fromIntegral (x1 * spacing), fromIntegral (y1 * spacing)), (fromIntegral (x2 * spacing), fromIntegral (y2 * spacing))]



-- Draw the piece if there is a piece on the particular position.
-- If the condition is satisfied, draw the piece by calling the drawCircle function with the particular colour.
-- @Board to get all pieces on the board. @Position the current position. @[Picture] the list of bitmap images. @Picture the graphical board with a new piece on it.
drawPiece :: Board -> Position -> [Picture] -> Picture
drawPiece b p bmps = case getPiece (pieces b) p of
                          Just piece -> drawCircle p (snd piece) "nothint" bmps
                          Nothing -> if (p == (hint b) && ((hints b)))
                                        then (drawCircle p Black "hint" bmps)
                                     else (drawCircle p Black "grey" bmps)
          where col Black = Color black
                col White = Color white


-- Draw a Black or White chip in a given position. Or it will draw a grey dot or a hint chip in a given position.
-- So, it will check the colour first, and will check the string. Then, it will draw suitable image on the board.
-- @Position the current position. @Col the color of the chip. @String to check if the drawCircle function should draw a chip or something else.
-- @[Picture] the list of bmp images. @Picture the generated output image.
drawCircle :: Position -> Col -> String -> [Picture] -> Picture
drawCircle (x, y) Black "hint" bmps = drawImage (x, y) (bmps!!0)
drawCircle (x, y) Black "nothint" bmps = drawImage (x, y) (bmps!!1)
drawCircle (x, y) White "nothint" bmps = drawImage (x, y) (bmps!!2)
drawCircle (x, y) Black "grey" bmps = (Color (greyN 0.4) $ Translate (fromIntegral (x * spacing)) (fromIntegral (y * spacing)) $ ThickCircle 2 2)

-- Check whether the game is finished or not. If so, print out the winner of the game on the board.
-- @World to get the board. @[Picture] the list of bmp images.
-- @[Picture] it will return the suitable winner image if the game is over. Otherwise, the checkEnd will return the empty list.
checkEnd :: World -> [Picture] -> [Picture]
checkEnd w bmps = case checkWon (board w) of
                       Just c  -> [printOutWinner c bmps]
                       Nothing -> []

-- Draw the image on the given position.
-- @Position the current position. @Picture the bmp image to draw on the gird. @Picture the generated output image.
drawImage :: Position -> Picture -> Picture
drawImage (x, y) bmp = Translate (fromIntegral (x * spacing)) (fromIntegral (y * spacing)) $ bmp

--The scale of the text
scaler = 0.4

-- Prints out the winner message by using the corresponding bmp image.
-- @Col the colour of the winner. @[Picture] list of bmp images. @Picture corresponding winner bmp image.
printOutWinner :: Col -> [Picture] -> Picture
printOutWinner Black bmps = drawImage (0, 0) (bmps!!0)
printOutWinner White bmps = drawImage (0, 0) (bmps!!1)

-- Returns the text "Welcome To Gomoku!".
-- @World to draw image on the board. @Picture the welcome text.
welcomeToGomoku :: World -> Picture
welcomeToGomoku w = color white $ Translate (-300) (-150) (scale scaler scaler (text "Welcome To Gomoku!"))

-- Draws all buttons that the option page requires.
-- To draw the buttons on the board, this function checks the every vertex of the button.
-- Then, it draws the buttons on the corresponding positions.
-- Used the map function to do same process to all elements in the list.
-- @World to draw buttons on the board. @(Float, Float) the vertex of the game grid. @[Button] list of all buttons. @[Picture] list of all button images.
drawButtonsForLoading :: World -> (Float, Float) -> [Button] -> [Picture]
drawButtonsForLoading w size = map drawB
  -- Move the button to the correct position
  where drawB b = Translate (fromIntegral $
                    (fst (topLeft b) - fst (bottomRight b)) `div` 2 + fst (bottomRight b))
                  (fromIntegral $
                    (snd (topLeft b) - snd (bottomRight b)) `div` 2 + snd (bottomRight b))
                  (Pictures (
                   -- Draw a white rectangle for the button. Then write the text with a black colour.
                   color white (polygon (rectanglePath (fst(size)) (snd(size)))) : [color black $ Translate (-1 * (fst(size)) / 2.5) (-5) (scale 0.1 0.1 (text $ value b))]
                  ))

-- This function draws the button on the board.
-- This function checks the every vertex of button, and draw the button on the corresponding position.
-- It calls itself recursively to draw all buttons on the board.
-- @[Button] the list of buttons which should be on the board. @[Picture] the list of button images. @[Picture] the list of all generated images. @[Picture] the list of bmp images.
drawButtons :: [Button] -> [Picture] -> [Picture] -> [Picture]
drawButtons [] ps [] = ps
drawButtons btns ps bmps = (Translate btn_x btn_y $ (head bmps)) : drawButtons (tail btns) ps (tail bmps)
            where b = head btns
                  btn_x = (fromIntegral $ (fst (topLeft b) - fst (bottomRight b)) `div` 2 + fst (bottomRight b))
                  btn_y = (fromIntegral $ (snd (topLeft b) - snd (bottomRight b)) `div` 2 + snd (bottomRight b))
